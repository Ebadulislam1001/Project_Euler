# Problem 3 - Largest Prime Factor
```
The prime factors of 13195 are 5, 7, 13 and 29.
What is the largest prime factor of the number 600851475143?
```

## Approach
The simplest approach is to run a loop and maintain a variable named `LPF` _(Largest Prime Factor)_.

In every iteration check -
- if the loop variable `i` is not a prime : continue to the next iteration
- elif the loop variable `i` is not a factor of N : continue to the next iteration 
- else : update the `LPF` since `i` is the new _Longest Prime Divisor_

Now everything boils down to how I am going to implement it.

### Code 1 - Too Simple, Too Slow 
```Python
# Python
N = 600851475143

def is_prime(n):
    for i in range(2, n):
        if n % i == 0:
            return False
    return True

def is_factor(n, f):
    return n % f == 0

LPF = 1
for i in range(2, N+1):
    if not is_prime(i):
        continue
    if not is_factor(N, i):
        continue
    LPF = i

print(f"Answer = {LPF}")
```
I let this code run for 5 whole minutes but I got no answer. TOO SLOW!!

### Optimisation
Now there are a bunch of smart math tricks that I can apply on this algorithm to make it better. 

#### 1. If a number is not divisible by any prime number smaller than itself, then it is also a Prime Number.
This allows me to make my `is_prime()` function faster by reducing the number of checks. Now I dont have to check the divisibility for each number in the range[2, i-1], but only for the already proven primes.

#### 2. If `p` divides `N/q`, and `p` and `q` are co-primes, then `p` also divides `N`.
This allows me to make my `is_factor()` function faster by reducing the big Number `N` everytime I find a prime factor it.
This way, the next time I wont be checking the divisibility for `N` but for its reduced form `N/q`.

***Note:*** this is true given the fact that I am only considering prime factors, because two primes are always co-primes.

#### 3. Finally I am going to change the `for loop` with a `while loop` because I want to control the number of iterations at run time.
I have tried to explain the exact reason of this in the [Bonus](#bonus) section.

### Code 2 - Smarter, Better, Faster
```Python
# Python
N = 600851475143

def is_prime(n, primes):
    for p in primes:        # checking the divisibility with the already found primes only
        if n % p == 0:
            return False
    return True

def is_factor(n, f):
    return n % f == 0

LPF = 1
primes = []
i = 2
while i <= N:
    if not is_prime(i, primes):
        i = i + 1
        continue
    primes.append(i)        # updating the list of primes found so far
    if not is_factor(N, i):
        i = i + 1
        continue
    N = N / i               # updating big number N to its reduced form N/q
    LPF = max(i, LPF)
print(f"Answer = {LPF}")
```
This code calculated the result in about 30 millisecond, which is far better than what our last code did.

## Answer
```
Answer = 6857
```

## Bonus
### How does `range()` works in Python and When not to use it in a for loop:
`range(n)` creates a range object, which is an iterator-like object. It generates each number on the fly.

Let's understand this with an example:
```C++
// C++
vector<int> nums = {1, 2, 3, 4, 5, 6};
for(int i=0; i<nums.size(); i++)
{
    printf("%d\n", nums[i]);
    nums.pop_back();
}
```
This `C++` code looks and works perfectly fine with no error what so ever.
```Python
# Python
nums = [1, 2, 3, 4, 5, 6]
for i in range(0, len(nums), 1):
    print(nums[i])
    nums.pop()
```
In this `Python` code looks like an exact counterpart to the `C++` above, but it isn't. This code causes a `runtime indexError`.

The issue with this code lies in the modification of the list `nums` while iterating over it using `range()`.
- the for loop iterates over the indices generated by `range(0, len(nums), 1)`, which is fixed at the start of the loop.
- the `nums.pop()` operation removes the last elements from the list, which affects the length of the list `(len(nums))` during iteration.
- however, the range object (which dictates the loop indices) does not adjust dynamically to reflect the shrinking size of the list.
- if the loop were to continue beyond the updated length of the list, it could result in an `IndexError`.

So if you want to control the number of iterations at run time, `range()` is not the right tool.
